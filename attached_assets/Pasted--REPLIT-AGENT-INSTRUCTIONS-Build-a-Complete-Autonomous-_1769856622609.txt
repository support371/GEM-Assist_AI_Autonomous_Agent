# ðŸ¤– REPLIT AGENT INSTRUCTIONS

## Build a Complete Autonomous AI Agent System

-----

## ðŸ“‹ PROJECT OVERVIEW

**Goal**: Build an autonomous AI agent with Replit Agent capabilities that can:

- Execute ANY programming task autonomously
- Understand context and requirements deeply
- Generate production-ready code
- Debug and fix issues automatically
- Handle multi-step complex workflows
- Provide live preview and execution
- Learn from project context

-----

## ðŸŽ¯ REPLIT AGENT - STEP-BY-STEP INSTRUCTIONS

### **Phase 1: Project Initialization (5 minutes)**

```bash
# 1. Create a new Next.js project in Replit
npm create next-app@latest autonomous-agent-system

# 2. Navigate to project
cd autonomous-agent-system

# 3. Install ALL required dependencies
npm install @anthropic-ai/sdk openai
npm install @prisma/client prisma
npm install tailwindcss postcss autoprefixer
npm install lucide-react clsx tailwind-merge
npm install zod react-hook-form @hookform/resolvers
npm install socket.io socket.io-client
npm install next-auth @auth/prisma-adapter bcryptjs
npm install recharts date-fns nanoid
npm install @radix-ui/react-dialog @radix-ui/react-dropdown-menu
npm install @radix-ui/react-select @radix-ui/react-toast
npm install @tiptap/react @tiptap/starter-kit
npm install zustand swr axios

# 4. Install dev dependencies
npm install -D @types/node @types/react @types/bcryptjs
npm install -D typescript @types/react-dom
npm install -D eslint eslint-config-next
```

-----

### **Phase 2: Environment Setup (3 minutes)**

Create `.env.local` file:

```env
# Database - Use Replit Database or external PostgreSQL
DATABASE_URL="postgresql://username:password@host:5432/database"

# AI Provider - Claude Sonnet 4 (Primary)
ANTHROPIC_API_KEY="sk-ant-api03-YOUR-KEY-HERE"

# Alternative AI Provider
OPENAI_API_KEY="sk-YOUR-KEY-HERE"

# NextAuth Configuration
NEXTAUTH_URL="https://your-replit-url.repl.co"
NEXTAUTH_SECRET="generate-with-openssl-rand-base64-32"

# Optional: OAuth Providers
GOOGLE_CLIENT_ID=""
GOOGLE_CLIENT_SECRET=""
GITHUB_CLIENT_ID=""
GITHUB_CLIENT_SECRET=""

# Redis for Caching (Optional)
REDIS_URL="redis://localhost:6379"

# Feature Flags
ENABLE_CODE_EXECUTION="true"
ENABLE_FILE_OPERATIONS="true"
ENABLE_WEB_SEARCH="true"
ENABLE_DEBUGGING="true"

# Production Settings
NODE_ENV="development"
```

-----

### **Phase 3: Database Schema (10 minutes)**

Create `prisma/schema.prisma` with this COMPLETE schema:

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============ CORE MODELS ============

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  password      String?
  avatar        String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  sessions              Session[]
  workspaces            WorkspaceMember[]
  projects              Project[]
  agentExecutions       AgentExecution[]
  agentConversations    AgentConversation[]
  codeSnapshots         CodeSnapshot[]
  executionLogs         ExecutionLog[]
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Workspace {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  settings    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members             WorkspaceMember[]
  projects            Project[]
  agentExecutions     AgentExecution[]
  agentConversations  AgentConversation[]
}

model WorkspaceMember {
  id          String   @id @default(cuid())
  role        String   @default("member")
  userId      String
  workspaceId String
  joinedAt    DateTime @default(now())

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([userId, workspaceId])
}

// ============ PROJECT MODELS ============

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  type        String   @default("general")
  language    String   @default("typescript")
  framework   String?
  status      String   @default("active")
  workspaceId String
  userId      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  workspace           Workspace           @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user                User                @relation(fields: [userId], references: [id])
  files               ProjectFile[]
  agentExecutions     AgentExecution[]
  agentConversations  AgentConversation[]
  codeSnapshots       CodeSnapshot[]

  @@index([workspaceId])
  @@index([userId])
}

model ProjectFile {
  id        String   @id @default(cuid())
  projectId String
  path      String
  content   String   @db.Text
  language  String
  size      Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, path])
  @@index([projectId])
}

// ============ AGENT EXECUTION MODELS ============

model AgentExecution {
  id          String    @id @default(cuid())
  task        String    @db.Text
  taskType    String    // code_generation, debugging, analysis, refactoring, testing
  status      String    // queued, running, completed, failed, cancelled
  priority    Int       @default(0)
  input       Json?
  output      Json?
  error       String?   @db.Text
  metadata    Json?
  workspaceId String?
  projectId   String?
  userId      String
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  duration    Int?      // in milliseconds

  user                User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace           Workspace?            @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  project             Project?              @relation(fields: [projectId], references: [id], onDelete: Cascade)
  steps               ExecutionStep[]
  logs                ExecutionLog[]
  generatedFiles      GeneratedFile[]
  tokenUsage          TokenUsage?

  @@index([userId])
  @@index([workspaceId])
  @@index([projectId])
  @@index([status])
  @@index([taskType])
}

model ExecutionStep {
  id          String    @id @default(cuid())
  executionId String
  stepNumber  Int
  name        String
  description String?
  status      String    // pending, running, completed, failed, skipped
  input       Json?
  output      Json?
  error       String?   @db.Text
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  duration    Int?

  execution AgentExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([executionId])
}

model ExecutionLog {
  id          String   @id @default(cuid())
  executionId String
  userId      String
  level       String   // info, warn, error, debug
  message     String   @db.Text
  metadata    Json?
  timestamp   DateTime @default(now())

  execution AgentExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([executionId])
  @@index([userId])
  @@index([level])
}

model GeneratedFile {
  id          String   @id @default(cuid())
  executionId String
  path        String
  content     String   @db.Text
  language    String
  size        Int
  isExecutable Boolean @default(false)
  createdAt   DateTime @default(now())

  execution AgentExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([executionId])
}

// ============ CONVERSATION MODELS ============

model AgentConversation {
  id          String   @id @default(cuid())
  title       String?
  userId      String
  workspaceId String?
  projectId   String?
  messages    Json     // Array of messages
  context     Json?    // Conversation context
  settings    Json?    // Agent settings for this conversation
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  project   Project?   @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([workspaceId])
  @@index([projectId])
}

// ============ CODE ANALYSIS MODELS ============

model CodeSnapshot {
  id          String   @id @default(cuid())
  projectId   String
  userId      String
  version     String
  description String?
  files       Json     // Snapshot of all files
  analysis    Json?    // Code analysis results
  metrics     Json?    // Code metrics
  createdAt   DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([userId])
}

// ============ USAGE & BILLING MODELS ============

model TokenUsage {
  id          String   @id @default(cuid())
  executionId String   @unique
  model       String
  inputTokens Int
  outputTokens Int
  totalTokens Int
  cost        Float
  timestamp   DateTime @default(now())

  execution AgentExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([timestamp])
}
```

Then run:

```bash
npx prisma generate
npx prisma db push
```

-----

### **Phase 4: Core Agent System (30 minutes)**

Create `lib/ai/autonomous-agent-core.ts`:

```typescript
import Anthropic from '@anthropic-ai/sdk';
import { prisma } from '@/lib/prisma';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

// ============ TOOL DEFINITIONS ============

export const AUTONOMOUS_AGENT_TOOLS = [
  {
    name: 'execute_code',
    description: 'Execute code in a sandboxed environment. Supports: JavaScript, TypeScript, Python, Bash',
    input_schema: {
      type: 'object',
      properties: {
        code: { type: 'string', description: 'Code to execute' },
        language: { type: 'string', enum: ['javascript', 'typescript', 'python', 'bash'] },
        context: { type: 'object', description: 'Execution context' }
      },
      required: ['code', 'language']
    }
  },
  {
    name: 'write_file',
    description: 'Create or update a file in the project',
    input_schema: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'File path' },
        content: { type: 'string', description: 'File content' },
        language: { type: 'string', description: 'Programming language' }
      },
      required: ['path', 'content']
    }
  },
  {
    name: 'read_file',
    description: 'Read a file from the project',
    input_schema: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'File path to read' }
      },
      required: ['path']
    }
  },
  {
    name: 'list_files',
    description: 'List all files in the project',
    input_schema: {
      type: 'object',
      properties: {
        directory: { type: 'string', description: 'Directory to list (optional)' }
      }
    }
  },
  {
    name: 'analyze_code',
    description: 'Analyze code for bugs, performance issues, best practices',
    input_schema: {
      type: 'object',
      properties: {
        code: { type: 'string', description: 'Code to analyze' },
        language: { type: 'string', description: 'Programming language' },
        focus: { type: 'array', items: { type: 'string' }, description: 'Analysis focus areas' }
      },
      required: ['code', 'language']
    }
  },
  {
    name: 'debug_code',
    description: 'Debug code and identify issues',
    input_schema: {
      type: 'object',
      properties: {
        code: { type: 'string', description: 'Code with bugs' },
        error: { type: 'string', description: 'Error message' },
        context: { type: 'string', description: 'Additional context' }
      },
      required: ['code']
    }
  },
  {
    name: 'refactor_code',
    description: 'Refactor code for better quality',
    input_schema: {
      type: 'object',
      properties: {
        code: { type: 'string', description: 'Code to refactor' },
        goals: { type: 'array', items: { type: 'string' }, description: 'Refactoring goals' }
      },
      required: ['code']
    }
  },
  {
    name: 'generate_tests',
    description: 'Generate unit tests for code',
    input_schema: {
      type: 'object',
      properties: {
        code: { type: 'string', description: 'Code to test' },
        framework: { type: 'string', description: 'Testing framework' }
      },
      required: ['code']
    }
  },
  {
    name: 'search_docs',
    description: 'Search programming documentation',
    input_schema: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'Search query' },
        source: { type: 'string', description: 'Docs source (mdn, react, node, etc)' }
      },
      required: ['query']
    }
  },
  {
    name: 'install_package',
    description: 'Install npm package to project',
    input_schema: {
      type: 'object',
      properties: {
        package: { type: 'string', description: 'Package name' },
        version: { type: 'string', description: 'Package version (optional)' },
        dev: { type: 'boolean', description: 'Install as dev dependency' }
      },
      required: ['package']
    }
  },
  {
    name: 'run_command',
    description: 'Run terminal command',
    input_schema: {
      type: 'object',
      properties: {
        command: { type: 'string', description: 'Command to run' },
        cwd: { type: 'string', description: 'Working directory' }
      },
      required: ['command']
    }
  }
];

// ============ AUTONOMOUS AGENT CLASS ============

export class AutonomousAgent {
  private executionId: string;
  private userId: string;
  private projectId?: string;
  private conversationHistory: any[] = [];

  constructor(userId: string, projectId?: string) {
    this.userId = userId;
    this.projectId = projectId;
    this.executionId = '';
  }

  /**
   * Execute task autonomously with multi-step reasoning
   */
  async executeTask(
    task: string,
    taskType: string = 'code_generation',
    onProgress?: (step: any) => void
  ) {
    // Create execution record
    const execution = await prisma.agentExecution.create({
      data: {
        task,
        taskType,
        status: 'running',
        userId: this.userId,
        projectId: this.projectId
      }
    });

    this.executionId = execution.id;

    try {
      // Step 1: Analyze task
      await this.logStep('Analyzing task requirements');
      if (onProgress) onProgress({ step: 'Analyzing task', progress: 10 });

      // Step 2: Plan execution
      const plan = await this.planExecution(task, taskType);
      await this.logStep('Execution plan created', plan);
      if (onProgress) onProgress({ step: 'Planning execution', progress: 20 });

      // Step 3: Execute plan
      const results = [];
      const totalSteps = plan.steps.length;

      for (let i = 0; i < plan.steps.length; i++) {
        const step = plan.steps[i];
        const progress = 20 + ((i + 1) / totalSteps) * 70;

        await this.logStep(\`Executing: \${step.name}\`);
        if (onProgress) onProgress({ step: step.name, progress });

        const result = await this.executeStep(step);
        results.push(result);

        await prisma.executionStep.create({
          data: {
            executionId: this.executionId,
            stepNumber: i + 1,
            name: step.name,
            description: step.description,
            status: result.success ? 'completed' : 'failed',
            output: result as any,
            completedAt: new Date()
          }
        });
      }

      // Step 4: Finalize
      await this.logStep('Finalizing execution');
      if (onProgress) onProgress({ step: 'Complete', progress: 100 });

      await prisma.agentExecution.update({
        where: { id: this.executionId },
        data: {
          status: 'completed',
          output: { results } as any,
          completedAt: new Date()
        }
      });

      return {
        success: true,
        executionId: this.executionId,
        results
      };

    } catch (error: any) {
      await prisma.agentExecution.update({
        where: { id: this.executionId },
        data: {
          status: 'failed',
          error: error.message,
          completedAt: new Date()
        }
      });

      throw error;
    }
  }

  /**
   * Plan execution using Claude
   */
  private async planExecution(task: string, taskType: string) {
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 4000,
      messages: [{
        role: 'user',
        content: \`You are an autonomous AI agent. Plan how to execute this task:

Task: \${task}
Type: \${taskType}

Create a detailed step-by-step execution plan. Return ONLY a JSON object with this structure:
{
  "analysis": "Brief analysis of the task",
  "steps": [
    {
      "name": "Step name",
      "description": "What this step does",
      "tool": "tool_name",
      "input": { "tool": "input" }
    }
  ]
}

Available tools: \${AUTONOMOUS_AGENT_TOOLS.map(t => t.name).join(', ')}

Return ONLY the JSON, nothing else.\`
      }]
    });

    const content = response.content[0];
    if (content.type !== 'text') throw new Error('Invalid response');

    // Extract JSON from response
    const jsonMatch = content.text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) throw new Error('No valid JSON in response');

    return JSON.parse(jsonMatch[0]);
  }

  /**
   * Execute a single step
   */
  private async executeStep(step: any) {
    // Implementation for each tool would go here
    // This is a simplified version
    return {
      success: true,
      tool: step.tool,
      output: \`Executed: \${step.name}\`
    };
  }

  /**
   * Log execution step
   */
  private async logStep(message: string, metadata?: any) {
    await prisma.executionLog.create({
      data: {
        executionId: this.executionId,
        userId: this.userId,
        level: 'info',
        message,
        metadata: metadata as any
      }
    });
  }
}
```

-----

### **Phase 5: API Routes (20 minutes)**

Create `app/api/agent/execute/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { AutonomousAgent } from '@/lib/ai/autonomous-agent-core';
import { getServerSession } from 'next-auth';

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession();
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { task, taskType, projectId } = await req.json();

    const agent = new AutonomousAgent(session.user.id, projectId);

    const result = await agent.executeTask(task, taskType);

    return NextResponse.json({ success: true, data: result });

  } catch (error: any) {
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```

-----

## ðŸŽ¨ COMPLETE FILE STRUCTURE

```
autonomous-agent-system/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â”‚   â”œâ”€â”€ execute/route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ stream/route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ chat/route.ts
â”‚   â”‚   â”‚   â””â”€â”€ tools/route.ts
â”‚   â”‚   â””â”€â”€ auth/[...nextauth]/route.ts
â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”œâ”€â”€ layout.tsx
â”‚   â””â”€â”€ page.tsx
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ AgentInterface.tsx
â”‚   â”œâ”€â”€ ExecutionViewer.tsx
â”‚   â”œâ”€â”€ CodeEditor.tsx
â”‚   â””â”€â”€ FileTree.tsx
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ ai/
â”‚   â”‚   â”œâ”€â”€ autonomous-agent-core.ts
â”‚   â”‚   â”œâ”€â”€ tool-executors.ts
â”‚   â”‚   â””â”€â”€ context-manager.ts
â”‚   â”œâ”€â”€ prisma.ts
â”‚   â””â”€â”€ auth.ts
â”œâ”€â”€ prisma/
â”‚   â””â”€â”€ schema.prisma
â”œâ”€â”€ .env.local
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

-----

## âš¡ QUICK START COMMANDS

```bash
# 1. Initialize
npm install

# 2. Setup database
npx prisma generate
npx prisma db push

# 3. Run development server
npm run dev

# 4. Access at
# https://your-replit-url.repl.co
```

-----

## ðŸŽ¯ TESTING THE AGENT

Try these commands:

```
"Build a React todo app with TypeScript"
"Debug this code: [paste code with error]"
"Refactor this component for better performance"
"Generate tests for this function"
"Create a REST API with Express"
```

-----

This complete system is now ready for Replit Agent to build! ðŸš€